// Copyright 2019-2023 Parity Technologies (UK) Ltd.
// This file is part of Parity Bridges Common.

// Parity Bridges Common is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Parity Bridges Common is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Parity Bridges Common.  If not, see <http://www.gnu.org/licenses/>.

//! Autogenerated runtime API
//! THIS FILE WAS AUTOGENERATED USING parity-bridges-common::runtime-codegen
//! EXECUTED COMMAND: tools/runtime-codegen/target/release/runtime-codegen --from-node-url http://localhost:9944

#[allow(dead_code, unused_imports, non_camel_case_types)]
#[allow(clippy::all)]
pub mod api {
	use super::api as root_mod;
	pub mod runtime_types {
		use super::runtime_types;
		pub mod aleph_runtime {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum OriginCaller {
				#[codec(index = 0)]
				system(
					runtime_types::frame_support::dispatch::RawOrigin<
						::sp_core::crypto::AccountId32,
					>,
				),
				#[codec(index = 1)]
				Void(runtime_types::sp_core::Void),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Runtime;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeCall {
				#[codec(index = 0)]
				System(runtime_types::frame_system::pallet::Call),
				#[codec(index = 2)]
				Scheduler(runtime_types::pallet_scheduler::pallet::Call),
				#[codec(index = 4)]
				Timestamp(runtime_types::pallet_timestamp::pallet::Call),
				#[codec(index = 5)]
				Balances(runtime_types::pallet_balances::pallet::Call),
				#[codec(index = 8)]
				Staking(runtime_types::pallet_staking::pallet::pallet::Call),
				#[codec(index = 10)]
				Session(runtime_types::pallet_session::pallet::Call),
				#[codec(index = 11)]
				Aleph(runtime_types::pallet_aleph::pallet::Call),
				#[codec(index = 12)]
				Elections(runtime_types::pallet_elections::pallet::Call),
				#[codec(index = 13)]
				Treasury(runtime_types::pallet_treasury::pallet::Call),
				#[codec(index = 14)]
				Vesting(runtime_types::pallet_vesting::pallet::Call),
				#[codec(index = 15)]
				Utility(runtime_types::pallet_utility::pallet::Call),
				#[codec(index = 16)]
				Multisig(runtime_types::pallet_multisig::pallet::Call),
				#[codec(index = 17)]
				Sudo(runtime_types::pallet_sudo::pallet::Call),
				#[codec(index = 18)]
				Contracts(runtime_types::pallet_contracts::pallet::Call),
				#[codec(index = 19)]
				NominationPools(runtime_types::pallet_nomination_pools::pallet::Call),
				#[codec(index = 20)]
				Identity(runtime_types::pallet_identity::pallet::Call),
				#[codec(index = 21)]
				CommitteeManagement(runtime_types::pallet_committee_management::pallet::Call),
				#[codec(index = 22)]
				BridgeWestendGrandpa(runtime_types::pallet_bridge_grandpa::pallet::Call),
				#[codec(index = 23)]
				BridgeAlephParachain(runtime_types::pallet_bridge_parachains::pallet::Call),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum RuntimeEvent {
				#[codec(index = 0)]
				System(runtime_types::frame_system::pallet::Event),
				#[codec(index = 2)]
				Scheduler(runtime_types::pallet_scheduler::pallet::Event),
				#[codec(index = 5)]
				Balances(runtime_types::pallet_balances::pallet::Event),
				#[codec(index = 6)]
				TransactionPayment(runtime_types::pallet_transaction_payment::pallet::Event),
				#[codec(index = 8)]
				Staking(runtime_types::pallet_staking::pallet::pallet::Event),
				#[codec(index = 10)]
				Session(runtime_types::pallet_session::pallet::Event),
				#[codec(index = 11)]
				Aleph(runtime_types::pallet_aleph::pallet::Event),
				#[codec(index = 12)]
				Elections(runtime_types::pallet_elections::pallet::Event),
				#[codec(index = 13)]
				Treasury(runtime_types::pallet_treasury::pallet::Event),
				#[codec(index = 14)]
				Vesting(runtime_types::pallet_vesting::pallet::Event),
				#[codec(index = 15)]
				Utility(runtime_types::pallet_utility::pallet::Event),
				#[codec(index = 16)]
				Multisig(runtime_types::pallet_multisig::pallet::Event),
				#[codec(index = 17)]
				Sudo(runtime_types::pallet_sudo::pallet::Event),
				#[codec(index = 18)]
				Contracts(runtime_types::pallet_contracts::pallet::Event),
				#[codec(index = 19)]
				NominationPools(runtime_types::pallet_nomination_pools::pallet::Event),
				#[codec(index = 20)]
				Identity(runtime_types::pallet_identity::pallet::Event),
				#[codec(index = 21)]
				CommitteeManagement(runtime_types::pallet_committee_management::pallet::Event),
				#[codec(index = 22)]
				BridgeWestendGrandpa(runtime_types::pallet_bridge_grandpa::pallet::Event),
				#[codec(index = 23)]
				BridgeAlephParachain(runtime_types::pallet_bridge_parachains::pallet::Event),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct SessionKeys {
				pub aura: runtime_types::sp_consensus_aura::sr25519::app_sr25519::Public,
				pub aleph: runtime_types::primitives::app::Public,
			}
		}
		pub mod bounded_collections {
			use super::runtime_types;
			pub mod bounded_btree_map {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BoundedBTreeMap<_0, _1>(pub ::subxt::utils::KeyedVec<_0, _1>);
			}
			pub mod bounded_vec {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BoundedVec<_0>(pub ::std::vec::Vec<_0>);
			}
			pub mod weak_bounded_vec {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct WeakBoundedVec<_0>(pub ::std::vec::Vec<_0>);
			}
		}
		pub mod bp_header_chain {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum HeaderChainError {
				#[codec(index = 0)]
				UnknownHeader,
				#[codec(index = 1)]
				StorageProof(runtime_types::bp_runtime::storage_proof::Error),
				#[codec(index = 2)]
				VecDb(runtime_types::bp_runtime::vec_db::VecDbError),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct StoredHeaderData<_0, _1> {
				pub number: _0,
				pub state_root: _1,
			}
		}
		pub mod bp_parachains {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct BestParaHeadHash {
				pub at_relay_block_number: ::core::primitive::u32,
				pub head_hash: ::subxt::utils::H256,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ParaInfo {
				pub best_head_hash: runtime_types::bp_parachains::BestParaHeadHash,
				pub next_imported_hash_position: ::core::primitive::u32,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ParaStoredHeaderData(pub ::std::vec::Vec<::core::primitive::u8>);
		}
		pub mod bp_runtime {
			use super::runtime_types;
			pub mod storage_proof {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					DuplicateNodesInProof,
					#[codec(index = 1)]
					UnusedNodesInTheProof,
					#[codec(index = 2)]
					StorageRootMismatch,
					#[codec(index = 3)]
					StorageValueUnavailable,
					#[codec(index = 4)]
					StorageValueEmpty,
					#[codec(index = 5)]
					StorageValueDecodeFailed(runtime_types::bp_runtime::StrippableError),
				}
			}
			pub mod vec_db {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum VecDbError {
					#[codec(index = 0)]
					UnableToGenerateTrieProof,
					#[codec(index = 1)]
					InvalidProof,
					#[codec(index = 2)]
					UnsortedEntries,
					#[codec(index = 3)]
					UnavailableKey,
					#[codec(index = 4)]
					EmptyVal,
					#[codec(index = 5)]
					DecodeError,
					#[codec(index = 6)]
					UnusedKey,
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum BasicOperatingMode {
				#[codec(index = 0)]
				Normal,
				#[codec(index = 1)]
				Halted,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct HeaderId<_0, _1>(pub _1, pub _0);
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum OwnedBridgeModuleError {
				#[codec(index = 0)]
				Halted,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct StrippableError;
		}
		pub mod finality_grandpa {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Commit<_0, _1, _2, _3> {
				pub target_hash: _0,
				pub target_number: _1,
				pub precommits: ::std::vec::Vec<
					runtime_types::finality_grandpa::SignedPrecommit<_0, _1, _2, _3>,
				>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Precommit<_0, _1> {
				pub target_hash: _0,
				pub target_number: _1,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct SignedPrecommit<_0, _1, _2, _3> {
				pub precommit: runtime_types::finality_grandpa::Precommit<_0, _1>,
				pub signature: _2,
				pub id: _3,
			}
		}
		pub mod frame_support {
			use super::runtime_types;
			pub mod dispatch {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum DispatchClass {
					#[codec(index = 0)]
					Normal,
					#[codec(index = 1)]
					Operational,
					#[codec(index = 2)]
					Mandatory,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct DispatchInfo {
					pub weight: ::sp_weights::Weight,
					pub class: runtime_types::frame_support::dispatch::DispatchClass,
					pub pays_fee: runtime_types::frame_support::dispatch::Pays,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Pays {
					#[codec(index = 0)]
					Yes,
					#[codec(index = 1)]
					No,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct PerDispatchClass<_0> {
					pub normal: _0,
					pub operational: _0,
					pub mandatory: _0,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum RawOrigin<_0> {
					#[codec(index = 0)]
					Root,
					#[codec(index = 1)]
					Signed(_0),
					#[codec(index = 2)]
					None,
				}
			}
			pub mod traits {
				use super::runtime_types;
				pub mod preimages {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Bounded<_0> {
						#[codec(index = 0)]
						Legacy {
							hash: ::subxt::utils::H256,
						},
						#[codec(index = 1)]
						Inline(
							runtime_types::bounded_collections::bounded_vec::BoundedVec<
								::core::primitive::u8,
							>,
						),
						#[codec(index = 2)]
						Lookup {
							hash: ::subxt::utils::H256,
							len: ::core::primitive::u32,
						},
						__Ignore(::core::marker::PhantomData<_0>),
					}
				}
				pub mod tokens {
					use super::runtime_types;
					pub mod misc {
						use super::runtime_types;
						#[derive(
							:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq,
						)]
						pub enum BalanceStatus {
							#[codec(index = 0)]
							Free,
							#[codec(index = 1)]
							Reserved,
						}
					}
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct PalletId(pub [::core::primitive::u8; 8usize]);
		}
		pub mod frame_system {
			use super::runtime_types;
			pub mod extensions {
				use super::runtime_types;
				pub mod check_genesis {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckGenesis;
				}
				pub mod check_mortality {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckMortality(pub ::sp_runtime::generic::Era);
				}
				pub mod check_non_zero_sender {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckNonZeroSender;
				}
				pub mod check_nonce {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckNonce(#[codec(compact)] pub ::core::primitive::u32);
				}
				pub mod check_spec_version {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckSpecVersion;
				}
				pub mod check_tx_version {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckTxVersion;
				}
				pub mod check_weight {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct CheckWeight;
				}
			}
			pub mod limits {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BlockLength {
					pub max: runtime_types::frame_support::dispatch::PerDispatchClass<
						::core::primitive::u32,
					>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct BlockWeights {
					pub base_block: ::sp_weights::Weight,
					pub max_block: ::sp_weights::Weight,
					pub per_class: runtime_types::frame_support::dispatch::PerDispatchClass<
						runtime_types::frame_system::limits::WeightsPerClass,
					>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct WeightsPerClass {
					pub base_extrinsic: ::sp_weights::Weight,
					pub max_extrinsic: ::core::option::Option<::sp_weights::Weight>,
					pub max_total: ::core::option::Option<::sp_weights::Weight>,
					pub reserved: ::core::option::Option<::sp_weights::Weight>,
				}
			}
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					remark { remark: ::std::vec::Vec<::core::primitive::u8> },
					#[codec(index = 1)]
					set_heap_pages { pages: ::core::primitive::u64 },
					#[codec(index = 2)]
					set_code { code: ::std::vec::Vec<::core::primitive::u8> },
					#[codec(index = 3)]
					set_code_without_checks { code: ::std::vec::Vec<::core::primitive::u8> },
					#[codec(index = 4)]
					set_storage {
						items: ::std::vec::Vec<(
							::std::vec::Vec<::core::primitive::u8>,
							::std::vec::Vec<::core::primitive::u8>,
						)>,
					},
					#[codec(index = 5)]
					kill_storage { keys: ::std::vec::Vec<::std::vec::Vec<::core::primitive::u8>> },
					#[codec(index = 6)]
					kill_prefix {
						prefix: ::std::vec::Vec<::core::primitive::u8>,
						subkeys: ::core::primitive::u32,
					},
					#[codec(index = 7)]
					remark_with_event { remark: ::std::vec::Vec<::core::primitive::u8> },
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidSpecName,
					#[codec(index = 1)]
					SpecVersionNeedsToIncrease,
					#[codec(index = 2)]
					FailedToExtractRuntimeVersion,
					#[codec(index = 3)]
					NonDefaultComposite,
					#[codec(index = 4)]
					NonZeroRefCount,
					#[codec(index = 5)]
					CallFiltered,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ExtrinsicSuccess {
						dispatch_info: runtime_types::frame_support::dispatch::DispatchInfo,
					},
					#[codec(index = 1)]
					ExtrinsicFailed {
						dispatch_error: runtime_types::sp_runtime::DispatchError,
						dispatch_info: runtime_types::frame_support::dispatch::DispatchInfo,
					},
					#[codec(index = 2)]
					CodeUpdated,
					#[codec(index = 3)]
					NewAccount { account: ::sp_core::crypto::AccountId32 },
					#[codec(index = 4)]
					KilledAccount { account: ::sp_core::crypto::AccountId32 },
					#[codec(index = 5)]
					Remarked { sender: ::sp_core::crypto::AccountId32, hash: ::subxt::utils::H256 },
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct AccountInfo<_0, _1> {
				pub nonce: _0,
				pub consumers: _0,
				pub providers: _0,
				pub sufficients: _0,
				pub data: _1,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct EventRecord<_0, _1> {
				pub phase: runtime_types::frame_system::Phase,
				pub event: _0,
				pub topics: ::std::vec::Vec<_1>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct LastRuntimeUpgradeInfo {
				#[codec(compact)]
				pub spec_version: ::core::primitive::u32,
				pub spec_name: ::std::string::String,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum Phase {
				#[codec(index = 0)]
				ApplyExtrinsic(::core::primitive::u32),
				#[codec(index = 1)]
				Finalization,
				#[codec(index = 2)]
				Initialization,
			}
		}
		pub mod pallet_aleph {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set_emergency_finalizer {
						emergency_finalizer: runtime_types::primitives::app::Public,
					},
					#[codec(index = 1)]
					schedule_finality_version_change {
						version_incoming: ::core::primitive::u32,
						session: ::core::primitive::u32,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ChangeEmergencyFinalizer(runtime_types::primitives::app::Public),
					#[codec(index = 1)]
					ScheduleFinalityVersionChange(runtime_types::primitives::VersionChange),
					#[codec(index = 2)]
					FinalityVersionChange(runtime_types::primitives::VersionChange),
				}
			}
		}
		pub mod pallet_balances {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					transfer {
						dest: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						#[codec(compact)]
						value: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					set_balance {
						who: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						#[codec(compact)]
						new_free: ::core::primitive::u128,
						#[codec(compact)]
						new_reserved: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					force_transfer {
						source: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						dest: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						#[codec(compact)]
						value: ::core::primitive::u128,
					},
					#[codec(index = 3)]
					transfer_keep_alive {
						dest: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						#[codec(compact)]
						value: ::core::primitive::u128,
					},
					#[codec(index = 4)]
					transfer_all {
						dest: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						keep_alive: ::core::primitive::bool,
					},
					#[codec(index = 5)]
					force_unreserve {
						who: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						amount: ::core::primitive::u128,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					VestingBalance,
					#[codec(index = 1)]
					LiquidityRestrictions,
					#[codec(index = 2)]
					InsufficientBalance,
					#[codec(index = 3)]
					ExistentialDeposit,
					#[codec(index = 4)]
					KeepAlive,
					#[codec(index = 5)]
					ExistingVestingSchedule,
					#[codec(index = 6)]
					DeadAccount,
					#[codec(index = 7)]
					TooManyReserves,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Endowed {
						account: ::sp_core::crypto::AccountId32,
						free_balance: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					DustLost {
						account: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					Transfer {
						from: ::sp_core::crypto::AccountId32,
						to: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 3)]
					BalanceSet {
						who: ::sp_core::crypto::AccountId32,
						free: ::core::primitive::u128,
						reserved: ::core::primitive::u128,
					},
					#[codec(index = 4)]
					Reserved {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 5)]
					Unreserved {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 6)]
					ReserveRepatriated {
						from: ::sp_core::crypto::AccountId32,
						to: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
						destination_status:
							runtime_types::frame_support::traits::tokens::misc::BalanceStatus,
					},
					#[codec(index = 7)]
					Deposit { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
					#[codec(index = 8)]
					Withdraw {
						who: ::sp_core::crypto::AccountId32,
						amount: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					Slashed { who: ::sp_core::crypto::AccountId32, amount: ::core::primitive::u128 },
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct AccountData<_0> {
				pub free: _0,
				pub reserved: _0,
				pub misc_frozen: _0,
				pub fee_frozen: _0,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct BalanceLock<_0> {
				pub id: [::core::primitive::u8; 8usize],
				pub amount: _0,
				pub reasons: runtime_types::pallet_balances::Reasons,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum Reasons {
				#[codec(index = 0)]
				Fee,
				#[codec(index = 1)]
				Misc,
				#[codec(index = 2)]
				All,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ReserveData<_0, _1> {
				pub id: _0,
				pub amount: _1,
			}
		}
		pub mod pallet_bridge_grandpa {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					submit_finality_proof {
						finality_target: ::std::boxed::Box<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
						justification: ::bp_header_chain::justification::GrandpaJustification<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
					},
					#[codec(index = 1)]
					initialize {
						init_data: ::bp_header_chain::InitializationData<
							::sp_runtime::generic::Header<
								::core::primitive::u32,
								::sp_runtime::traits::BlakeTwo256,
							>,
						>,
					},
					#[codec(index = 2)]
					set_owner { new_owner: ::core::option::Option<::sp_core::crypto::AccountId32> },
					#[codec(index = 3)]
					set_operating_mode {
						operating_mode: runtime_types::bp_runtime::BasicOperatingMode,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidJustification,
					#[codec(index = 1)]
					InvalidAuthoritySet,
					#[codec(index = 2)]
					OldHeader,
					#[codec(index = 3)]
					UnsupportedScheduledChange,
					#[codec(index = 4)]
					NotInitialized,
					#[codec(index = 5)]
					AlreadyInitialized,
					#[codec(index = 6)]
					TooManyAuthoritiesInSet,
					#[codec(index = 7)]
					BridgeModule(runtime_types::bp_runtime::OwnedBridgeModuleError),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					UpdatedBestFinalizedHeader {
						number: ::core::primitive::u32,
						hash: ::subxt::utils::H256,
					},
				}
			}
			pub mod storage_types {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct StoredAuthoritySet {
					pub authorities: runtime_types::bounded_collections::bounded_vec::BoundedVec<(
						runtime_types::sp_consensus_grandpa::app::Public,
						::core::primitive::u64,
					)>,
					pub set_id: ::core::primitive::u64,
				}
			}
		}
		pub mod pallet_bridge_parachains {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					submit_parachain_heads {
						at_relay_block: (::core::primitive::u32, ::subxt::utils::H256),
						parachains: ::std::vec::Vec<(
							::bp_polkadot_core::parachains::ParaId,
							::subxt::utils::H256,
						)>,
						parachain_heads_proof: ::bp_polkadot_core::parachains::ParaHeadsProof,
					},
					#[codec(index = 1)]
					set_owner { new_owner: ::core::option::Option<::sp_core::crypto::AccountId32> },
					#[codec(index = 2)]
					set_operating_mode {
						operating_mode: runtime_types::bp_runtime::BasicOperatingMode,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					UnknownRelayChainBlock,
					#[codec(index = 1)]
					InvalidRelayChainBlockNumber,
					#[codec(index = 2)]
					HeaderChainStorageProof(runtime_types::bp_header_chain::HeaderChainError),
					#[codec(index = 3)]
					BridgeModule(runtime_types::bp_runtime::OwnedBridgeModuleError),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					UntrackedParachainRejected { parachain: ::bp_polkadot_core::parachains::ParaId },
					#[codec(index = 1)]
					MissingParachainHead { parachain: ::bp_polkadot_core::parachains::ParaId },
					#[codec(index = 2)]
					IncorrectParachainHeadHash {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
						actual_parachain_head_hash: ::subxt::utils::H256,
					},
					#[codec(index = 3)]
					RejectedObsoleteParachainHead {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
					},
					#[codec(index = 4)]
					RejectedLargeParachainHead {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
						parachain_head_size: ::core::primitive::u32,
					},
					#[codec(index = 5)]
					UpdatedParachainHead {
						parachain: ::bp_polkadot_core::parachains::ParaId,
						parachain_head_hash: ::subxt::utils::H256,
					},
				}
			}
		}
		pub mod pallet_committee_management {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 1)]
					set_ban_config {
						minimal_expected_performance: ::core::option::Option<::core::primitive::u8>,
						underperformed_session_count_threshold:
							::core::option::Option<::core::primitive::u32>,
						clean_session_counter_delay: ::core::option::Option<::core::primitive::u32>,
						ban_period: ::core::option::Option<::core::primitive::u32>,
					},
					#[codec(index = 2)]
					ban_from_committee {
						banned: ::sp_core::crypto::AccountId32,
						ban_reason: ::std::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 3)]
					cancel_ban { banned: ::sp_core::crypto::AccountId32 },
					#[codec(index = 4)]
					set_lenient_threshold { threshold_percent: ::core::primitive::u8 },
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidBanConfig,
					#[codec(index = 1)]
					BanReasonTooBig,
					#[codec(index = 2)]
					InvalidLenientThreshold,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					SetBanConfig(runtime_types::primitives::BanConfig),
					#[codec(index = 1)]
					BanValidators(
						::std::vec::Vec<(
							::sp_core::crypto::AccountId32,
							runtime_types::primitives::BanInfo,
						)>,
					),
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct CurrentAndNextSessionValidators<_0> {
				pub next: runtime_types::primitives::SessionValidators<_0>,
				pub current: runtime_types::primitives::SessionValidators<_0>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ValidatorTotalRewards<_0>(
				pub ::subxt::utils::KeyedVec<_0, ::core::primitive::u32>,
			);
		}
		pub mod pallet_contracts {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					call_old_weight {
						dest: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						#[codec(compact)]
						value: ::core::primitive::u128,
						#[codec(compact)]
						gas_limit: runtime_types::sp_weights::OldWeight,
						storage_deposit_limit: ::core::option::Option<
							::subxt::ext::codec::Compact<::core::primitive::u128>,
						>,
						data: ::std::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 1)]
					instantiate_with_code_old_weight {
						#[codec(compact)]
						value: ::core::primitive::u128,
						#[codec(compact)]
						gas_limit: runtime_types::sp_weights::OldWeight,
						storage_deposit_limit: ::core::option::Option<
							::subxt::ext::codec::Compact<::core::primitive::u128>,
						>,
						code: ::std::vec::Vec<::core::primitive::u8>,
						data: ::std::vec::Vec<::core::primitive::u8>,
						salt: ::std::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 2)]
					instantiate_old_weight {
						#[codec(compact)]
						value: ::core::primitive::u128,
						#[codec(compact)]
						gas_limit: runtime_types::sp_weights::OldWeight,
						storage_deposit_limit: ::core::option::Option<
							::subxt::ext::codec::Compact<::core::primitive::u128>,
						>,
						code_hash: ::subxt::utils::H256,
						data: ::std::vec::Vec<::core::primitive::u8>,
						salt: ::std::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 3)]
					upload_code {
						code: ::std::vec::Vec<::core::primitive::u8>,
						storage_deposit_limit: ::core::option::Option<
							::subxt::ext::codec::Compact<::core::primitive::u128>,
						>,
						determinism: runtime_types::pallet_contracts::wasm::Determinism,
					},
					#[codec(index = 4)]
					remove_code { code_hash: ::subxt::utils::H256 },
					#[codec(index = 5)]
					set_code {
						dest: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						code_hash: ::subxt::utils::H256,
					},
					#[codec(index = 6)]
					call {
						dest: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						#[codec(compact)]
						value: ::core::primitive::u128,
						gas_limit: ::sp_weights::Weight,
						storage_deposit_limit: ::core::option::Option<
							::subxt::ext::codec::Compact<::core::primitive::u128>,
						>,
						data: ::std::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 7)]
					instantiate_with_code {
						#[codec(compact)]
						value: ::core::primitive::u128,
						gas_limit: ::sp_weights::Weight,
						storage_deposit_limit: ::core::option::Option<
							::subxt::ext::codec::Compact<::core::primitive::u128>,
						>,
						code: ::std::vec::Vec<::core::primitive::u8>,
						data: ::std::vec::Vec<::core::primitive::u8>,
						salt: ::std::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 8)]
					instantiate {
						#[codec(compact)]
						value: ::core::primitive::u128,
						gas_limit: ::sp_weights::Weight,
						storage_deposit_limit: ::core::option::Option<
							::subxt::ext::codec::Compact<::core::primitive::u128>,
						>,
						code_hash: ::subxt::utils::H256,
						data: ::std::vec::Vec<::core::primitive::u8>,
						salt: ::std::vec::Vec<::core::primitive::u8>,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidScheduleVersion,
					#[codec(index = 1)]
					InvalidCallFlags,
					#[codec(index = 2)]
					OutOfGas,
					#[codec(index = 3)]
					OutputBufferTooSmall,
					#[codec(index = 4)]
					TransferFailed,
					#[codec(index = 5)]
					MaxCallDepthReached,
					#[codec(index = 6)]
					ContractNotFound,
					#[codec(index = 7)]
					CodeTooLarge,
					#[codec(index = 8)]
					CodeNotFound,
					#[codec(index = 9)]
					OutOfBounds,
					#[codec(index = 10)]
					DecodingFailed,
					#[codec(index = 11)]
					ContractTrapped,
					#[codec(index = 12)]
					ValueTooLarge,
					#[codec(index = 13)]
					TerminatedWhileReentrant,
					#[codec(index = 14)]
					InputForwarded,
					#[codec(index = 15)]
					RandomSubjectTooLong,
					#[codec(index = 16)]
					TooManyTopics,
					#[codec(index = 17)]
					NoChainExtension,
					#[codec(index = 18)]
					DeletionQueueFull,
					#[codec(index = 19)]
					DuplicateContract,
					#[codec(index = 20)]
					TerminatedInConstructor,
					#[codec(index = 21)]
					ReentranceDenied,
					#[codec(index = 22)]
					StorageDepositNotEnoughFunds,
					#[codec(index = 23)]
					StorageDepositLimitExhausted,
					#[codec(index = 24)]
					CodeInUse,
					#[codec(index = 25)]
					ContractReverted,
					#[codec(index = 26)]
					CodeRejected,
					#[codec(index = 27)]
					Indeterministic,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Instantiated {
						deployer: ::sp_core::crypto::AccountId32,
						contract: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 1)]
					Terminated {
						contract: ::sp_core::crypto::AccountId32,
						beneficiary: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 2)]
					CodeStored { code_hash: ::subxt::utils::H256 },
					#[codec(index = 3)]
					ContractEmitted {
						contract: ::sp_core::crypto::AccountId32,
						data: ::std::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 4)]
					CodeRemoved { code_hash: ::subxt::utils::H256 },
					#[codec(index = 5)]
					ContractCodeUpdated {
						contract: ::sp_core::crypto::AccountId32,
						new_code_hash: ::subxt::utils::H256,
						old_code_hash: ::subxt::utils::H256,
					},
					#[codec(index = 6)]
					Called {
						caller: ::sp_core::crypto::AccountId32,
						contract: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 7)]
					DelegateCalled {
						contract: ::sp_core::crypto::AccountId32,
						code_hash: ::subxt::utils::H256,
					},
				}
			}
			pub mod schedule {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct HostFnWeights {
					pub caller: ::sp_weights::Weight,
					pub is_contract: ::sp_weights::Weight,
					pub code_hash: ::sp_weights::Weight,
					pub own_code_hash: ::sp_weights::Weight,
					pub caller_is_origin: ::sp_weights::Weight,
					pub address: ::sp_weights::Weight,
					pub gas_left: ::sp_weights::Weight,
					pub balance: ::sp_weights::Weight,
					pub value_transferred: ::sp_weights::Weight,
					pub minimum_balance: ::sp_weights::Weight,
					pub block_number: ::sp_weights::Weight,
					pub now: ::sp_weights::Weight,
					pub weight_to_fee: ::sp_weights::Weight,
					pub gas: ::sp_weights::Weight,
					pub input: ::sp_weights::Weight,
					pub input_per_byte: ::sp_weights::Weight,
					pub r#return: ::sp_weights::Weight,
					pub return_per_byte: ::sp_weights::Weight,
					pub terminate: ::sp_weights::Weight,
					pub random: ::sp_weights::Weight,
					pub deposit_event: ::sp_weights::Weight,
					pub deposit_event_per_topic: ::sp_weights::Weight,
					pub deposit_event_per_byte: ::sp_weights::Weight,
					pub debug_message: ::sp_weights::Weight,
					pub debug_message_per_byte: ::sp_weights::Weight,
					pub set_storage: ::sp_weights::Weight,
					pub set_storage_per_new_byte: ::sp_weights::Weight,
					pub set_storage_per_old_byte: ::sp_weights::Weight,
					pub set_code_hash: ::sp_weights::Weight,
					pub clear_storage: ::sp_weights::Weight,
					pub clear_storage_per_byte: ::sp_weights::Weight,
					pub contains_storage: ::sp_weights::Weight,
					pub contains_storage_per_byte: ::sp_weights::Weight,
					pub get_storage: ::sp_weights::Weight,
					pub get_storage_per_byte: ::sp_weights::Weight,
					pub take_storage: ::sp_weights::Weight,
					pub take_storage_per_byte: ::sp_weights::Weight,
					pub transfer: ::sp_weights::Weight,
					pub call: ::sp_weights::Weight,
					pub delegate_call: ::sp_weights::Weight,
					pub call_transfer_surcharge: ::sp_weights::Weight,
					pub call_per_cloned_byte: ::sp_weights::Weight,
					pub instantiate: ::sp_weights::Weight,
					pub instantiate_transfer_surcharge: ::sp_weights::Weight,
					pub instantiate_per_input_byte: ::sp_weights::Weight,
					pub instantiate_per_salt_byte: ::sp_weights::Weight,
					pub hash_sha2_256: ::sp_weights::Weight,
					pub hash_sha2_256_per_byte: ::sp_weights::Weight,
					pub hash_keccak_256: ::sp_weights::Weight,
					pub hash_keccak_256_per_byte: ::sp_weights::Weight,
					pub hash_blake2_256: ::sp_weights::Weight,
					pub hash_blake2_256_per_byte: ::sp_weights::Weight,
					pub hash_blake2_128: ::sp_weights::Weight,
					pub hash_blake2_128_per_byte: ::sp_weights::Weight,
					pub ecdsa_recover: ::sp_weights::Weight,
					pub ecdsa_to_eth_address: ::sp_weights::Weight,
					pub reentrance_count: ::sp_weights::Weight,
					pub account_reentrance_count: ::sp_weights::Weight,
					pub instantiation_nonce: ::sp_weights::Weight,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct InstructionWeights {
					pub version: ::core::primitive::u32,
					pub fallback: ::core::primitive::u32,
					pub i64const: ::core::primitive::u32,
					pub i64load: ::core::primitive::u32,
					pub i64store: ::core::primitive::u32,
					pub select: ::core::primitive::u32,
					pub r#if: ::core::primitive::u32,
					pub br: ::core::primitive::u32,
					pub br_if: ::core::primitive::u32,
					pub br_table: ::core::primitive::u32,
					pub br_table_per_entry: ::core::primitive::u32,
					pub call: ::core::primitive::u32,
					pub call_indirect: ::core::primitive::u32,
					pub call_indirect_per_param: ::core::primitive::u32,
					pub call_per_local: ::core::primitive::u32,
					pub local_get: ::core::primitive::u32,
					pub local_set: ::core::primitive::u32,
					pub local_tee: ::core::primitive::u32,
					pub global_get: ::core::primitive::u32,
					pub global_set: ::core::primitive::u32,
					pub memory_current: ::core::primitive::u32,
					pub memory_grow: ::core::primitive::u32,
					pub i64clz: ::core::primitive::u32,
					pub i64ctz: ::core::primitive::u32,
					pub i64popcnt: ::core::primitive::u32,
					pub i64eqz: ::core::primitive::u32,
					pub i64extendsi32: ::core::primitive::u32,
					pub i64extendui32: ::core::primitive::u32,
					pub i32wrapi64: ::core::primitive::u32,
					pub i64eq: ::core::primitive::u32,
					pub i64ne: ::core::primitive::u32,
					pub i64lts: ::core::primitive::u32,
					pub i64ltu: ::core::primitive::u32,
					pub i64gts: ::core::primitive::u32,
					pub i64gtu: ::core::primitive::u32,
					pub i64les: ::core::primitive::u32,
					pub i64leu: ::core::primitive::u32,
					pub i64ges: ::core::primitive::u32,
					pub i64geu: ::core::primitive::u32,
					pub i64add: ::core::primitive::u32,
					pub i64sub: ::core::primitive::u32,
					pub i64mul: ::core::primitive::u32,
					pub i64divs: ::core::primitive::u32,
					pub i64divu: ::core::primitive::u32,
					pub i64rems: ::core::primitive::u32,
					pub i64remu: ::core::primitive::u32,
					pub i64and: ::core::primitive::u32,
					pub i64or: ::core::primitive::u32,
					pub i64xor: ::core::primitive::u32,
					pub i64shl: ::core::primitive::u32,
					pub i64shrs: ::core::primitive::u32,
					pub i64shru: ::core::primitive::u32,
					pub i64rotl: ::core::primitive::u32,
					pub i64rotr: ::core::primitive::u32,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Limits {
					pub event_topics: ::core::primitive::u32,
					pub globals: ::core::primitive::u32,
					pub locals: ::core::primitive::u32,
					pub parameters: ::core::primitive::u32,
					pub memory_pages: ::core::primitive::u32,
					pub table_size: ::core::primitive::u32,
					pub br_table_size: ::core::primitive::u32,
					pub subject_len: ::core::primitive::u32,
					pub payload_len: ::core::primitive::u32,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Schedule {
					pub limits: runtime_types::pallet_contracts::schedule::Limits,
					pub instruction_weights:
						runtime_types::pallet_contracts::schedule::InstructionWeights,
					pub host_fn_weights: runtime_types::pallet_contracts::schedule::HostFnWeights,
				}
			}
			pub mod storage {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct ContractInfo {
					pub trie_id: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
					pub deposit_account: runtime_types::pallet_contracts::storage::DepositAccount,
					pub code_hash: ::subxt::utils::H256,
					pub storage_bytes: ::core::primitive::u32,
					pub storage_items: ::core::primitive::u32,
					pub storage_byte_deposit: ::core::primitive::u128,
					pub storage_item_deposit: ::core::primitive::u128,
					pub storage_base_deposit: ::core::primitive::u128,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct DeletedContract {
					pub trie_id: runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct DepositAccount(pub ::sp_core::crypto::AccountId32);
			}
			pub mod wasm {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Determinism {
					#[codec(index = 0)]
					Deterministic,
					#[codec(index = 1)]
					AllowIndeterminism,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct OwnerInfo {
					pub owner: ::sp_core::crypto::AccountId32,
					#[codec(compact)]
					pub deposit: ::core::primitive::u128,
					#[codec(compact)]
					pub refcount: ::core::primitive::u64,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct PrefabWasmModule {
					#[codec(compact)]
					pub instruction_weights_version: ::core::primitive::u32,
					#[codec(compact)]
					pub initial: ::core::primitive::u32,
					#[codec(compact)]
					pub maximum: ::core::primitive::u32,
					pub code: runtime_types::bounded_collections::weak_bounded_vec::WeakBoundedVec<
						::core::primitive::u8,
					>,
					pub determinism: runtime_types::pallet_contracts::wasm::Determinism,
				}
			}
		}
		pub mod pallet_elections {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					change_validators {
						reserved_validators:
							::core::option::Option<::std::vec::Vec<::sp_core::crypto::AccountId32>>,
						non_reserved_validators:
							::core::option::Option<::std::vec::Vec<::sp_core::crypto::AccountId32>>,
						committee_size:
							::core::option::Option<runtime_types::primitives::CommitteeSeats>,
					},
					#[codec(index = 4)]
					set_elections_openness { openness: runtime_types::primitives::ElectionOpenness },
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					NotEnoughValidators,
					#[codec(index = 1)]
					NotEnoughReservedValidators,
					#[codec(index = 2)]
					NotEnoughNonReservedValidators,
					#[codec(index = 3)]
					NonUniqueListOfValidators,
					#[codec(index = 4)]
					NonReservedFinalitySeatsLargerThanNonReservedSeats,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					ChangeValidators(
						::std::vec::Vec<::sp_core::crypto::AccountId32>,
						::std::vec::Vec<::sp_core::crypto::AccountId32>,
						runtime_types::primitives::CommitteeSeats,
					),
				}
			}
		}
		pub mod pallet_identity {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					add_registrar {
						account: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
					},
					#[codec(index = 1)]
					set_identity {
						info:
							::std::boxed::Box<runtime_types::pallet_identity::types::IdentityInfo>,
					},
					#[codec(index = 2)]
					set_subs {
						subs: ::std::vec::Vec<(
							::sp_core::crypto::AccountId32,
							runtime_types::pallet_identity::types::Data,
						)>,
					},
					#[codec(index = 3)]
					clear_identity,
					#[codec(index = 4)]
					request_judgement {
						#[codec(compact)]
						reg_index: ::core::primitive::u32,
						#[codec(compact)]
						max_fee: ::core::primitive::u128,
					},
					#[codec(index = 5)]
					cancel_request { reg_index: ::core::primitive::u32 },
					#[codec(index = 6)]
					set_fee {
						#[codec(compact)]
						index: ::core::primitive::u32,
						#[codec(compact)]
						fee: ::core::primitive::u128,
					},
					#[codec(index = 7)]
					set_account_id {
						#[codec(compact)]
						index: ::core::primitive::u32,
						new: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
					},
					#[codec(index = 8)]
					set_fields {
						#[codec(compact)]
						index: ::core::primitive::u32,
						fields: runtime_types::pallet_identity::types::BitFlags<
							runtime_types::pallet_identity::types::IdentityField,
						>,
					},
					#[codec(index = 9)]
					provide_judgement {
						#[codec(compact)]
						reg_index: ::core::primitive::u32,
						target: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						judgement: runtime_types::pallet_identity::types::Judgement<
							::core::primitive::u128,
						>,
						identity: ::subxt::utils::H256,
					},
					#[codec(index = 10)]
					kill_identity {
						target: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
					},
					#[codec(index = 11)]
					add_sub {
						sub: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						data: runtime_types::pallet_identity::types::Data,
					},
					#[codec(index = 12)]
					rename_sub {
						sub: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						data: runtime_types::pallet_identity::types::Data,
					},
					#[codec(index = 13)]
					remove_sub {
						sub: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
					},
					#[codec(index = 14)]
					quit_sub,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					TooManySubAccounts,
					#[codec(index = 1)]
					NotFound,
					#[codec(index = 2)]
					NotNamed,
					#[codec(index = 3)]
					EmptyIndex,
					#[codec(index = 4)]
					FeeChanged,
					#[codec(index = 5)]
					NoIdentity,
					#[codec(index = 6)]
					StickyJudgement,
					#[codec(index = 7)]
					JudgementGiven,
					#[codec(index = 8)]
					InvalidJudgement,
					#[codec(index = 9)]
					InvalidIndex,
					#[codec(index = 10)]
					InvalidTarget,
					#[codec(index = 11)]
					TooManyFields,
					#[codec(index = 12)]
					TooManyRegistrars,
					#[codec(index = 13)]
					AlreadyClaimed,
					#[codec(index = 14)]
					NotSub,
					#[codec(index = 15)]
					NotOwned,
					#[codec(index = 16)]
					JudgementForDifferentIdentity,
					#[codec(index = 17)]
					JudgementPaymentFailed,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					IdentitySet { who: ::sp_core::crypto::AccountId32 },
					#[codec(index = 1)]
					IdentityCleared {
						who: ::sp_core::crypto::AccountId32,
						deposit: ::core::primitive::u128,
					},
					#[codec(index = 2)]
					IdentityKilled {
						who: ::sp_core::crypto::AccountId32,
						deposit: ::core::primitive::u128,
					},
					#[codec(index = 3)]
					JudgementRequested {
						who: ::sp_core::crypto::AccountId32,
						registrar_index: ::core::primitive::u32,
					},
					#[codec(index = 4)]
					JudgementUnrequested {
						who: ::sp_core::crypto::AccountId32,
						registrar_index: ::core::primitive::u32,
					},
					#[codec(index = 5)]
					JudgementGiven {
						target: ::sp_core::crypto::AccountId32,
						registrar_index: ::core::primitive::u32,
					},
					#[codec(index = 6)]
					RegistrarAdded { registrar_index: ::core::primitive::u32 },
					#[codec(index = 7)]
					SubIdentityAdded {
						sub: ::sp_core::crypto::AccountId32,
						main: ::sp_core::crypto::AccountId32,
						deposit: ::core::primitive::u128,
					},
					#[codec(index = 8)]
					SubIdentityRemoved {
						sub: ::sp_core::crypto::AccountId32,
						main: ::sp_core::crypto::AccountId32,
						deposit: ::core::primitive::u128,
					},
					#[codec(index = 9)]
					SubIdentityRevoked {
						sub: ::sp_core::crypto::AccountId32,
						main: ::sp_core::crypto::AccountId32,
						deposit: ::core::primitive::u128,
					},
				}
			}
			pub mod types {
				use super::runtime_types;
				#[derive(
					:: codec :: Decode,
					:: codec :: Encode,
					:: subxt :: ext :: codec :: CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct BitFlags<_0>(
					pub ::core::primitive::u64,
					#[codec(skip)] pub ::core::marker::PhantomData<_0>,
				);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Data {
					#[codec(index = 0)]
					None,
					#[codec(index = 1)]
					Raw0([::core::primitive::u8; 0usize]),
					#[codec(index = 2)]
					Raw1([::core::primitive::u8; 1usize]),
					#[codec(index = 3)]
					Raw2([::core::primitive::u8; 2usize]),
					#[codec(index = 4)]
					Raw3([::core::primitive::u8; 3usize]),
					#[codec(index = 5)]
					Raw4([::core::primitive::u8; 4usize]),
					#[codec(index = 6)]
					Raw5([::core::primitive::u8; 5usize]),
					#[codec(index = 7)]
					Raw6([::core::primitive::u8; 6usize]),
					#[codec(index = 8)]
					Raw7([::core::primitive::u8; 7usize]),
					#[codec(index = 9)]
					Raw8([::core::primitive::u8; 8usize]),
					#[codec(index = 10)]
					Raw9([::core::primitive::u8; 9usize]),
					#[codec(index = 11)]
					Raw10([::core::primitive::u8; 10usize]),
					#[codec(index = 12)]
					Raw11([::core::primitive::u8; 11usize]),
					#[codec(index = 13)]
					Raw12([::core::primitive::u8; 12usize]),
					#[codec(index = 14)]
					Raw13([::core::primitive::u8; 13usize]),
					#[codec(index = 15)]
					Raw14([::core::primitive::u8; 14usize]),
					#[codec(index = 16)]
					Raw15([::core::primitive::u8; 15usize]),
					#[codec(index = 17)]
					Raw16([::core::primitive::u8; 16usize]),
					#[codec(index = 18)]
					Raw17([::core::primitive::u8; 17usize]),
					#[codec(index = 19)]
					Raw18([::core::primitive::u8; 18usize]),
					#[codec(index = 20)]
					Raw19([::core::primitive::u8; 19usize]),
					#[codec(index = 21)]
					Raw20([::core::primitive::u8; 20usize]),
					#[codec(index = 22)]
					Raw21([::core::primitive::u8; 21usize]),
					#[codec(index = 23)]
					Raw22([::core::primitive::u8; 22usize]),
					#[codec(index = 24)]
					Raw23([::core::primitive::u8; 23usize]),
					#[codec(index = 25)]
					Raw24([::core::primitive::u8; 24usize]),
					#[codec(index = 26)]
					Raw25([::core::primitive::u8; 25usize]),
					#[codec(index = 27)]
					Raw26([::core::primitive::u8; 26usize]),
					#[codec(index = 28)]
					Raw27([::core::primitive::u8; 27usize]),
					#[codec(index = 29)]
					Raw28([::core::primitive::u8; 28usize]),
					#[codec(index = 30)]
					Raw29([::core::primitive::u8; 29usize]),
					#[codec(index = 31)]
					Raw30([::core::primitive::u8; 30usize]),
					#[codec(index = 32)]
					Raw31([::core::primitive::u8; 31usize]),
					#[codec(index = 33)]
					Raw32([::core::primitive::u8; 32usize]),
					#[codec(index = 34)]
					BlakeTwo256([::core::primitive::u8; 32usize]),
					#[codec(index = 35)]
					Sha256([::core::primitive::u8; 32usize]),
					#[codec(index = 36)]
					Keccak256([::core::primitive::u8; 32usize]),
					#[codec(index = 37)]
					ShaThree256([::core::primitive::u8; 32usize]),
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum IdentityField {
					#[codec(index = 1)]
					Display,
					#[codec(index = 2)]
					Legal,
					#[codec(index = 4)]
					Web,
					#[codec(index = 8)]
					Riot,
					#[codec(index = 16)]
					Email,
					#[codec(index = 32)]
					PgpFingerprint,
					#[codec(index = 64)]
					Image,
					#[codec(index = 128)]
					Twitter,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct IdentityInfo {
					pub additional: runtime_types::bounded_collections::bounded_vec::BoundedVec<(
						runtime_types::pallet_identity::types::Data,
						runtime_types::pallet_identity::types::Data,
					)>,
					pub display: runtime_types::pallet_identity::types::Data,
					pub legal: runtime_types::pallet_identity::types::Data,
					pub web: runtime_types::pallet_identity::types::Data,
					pub riot: runtime_types::pallet_identity::types::Data,
					pub email: runtime_types::pallet_identity::types::Data,
					pub pgp_fingerprint: ::core::option::Option<[::core::primitive::u8; 20usize]>,
					pub image: runtime_types::pallet_identity::types::Data,
					pub twitter: runtime_types::pallet_identity::types::Data,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Judgement<_0> {
					#[codec(index = 0)]
					Unknown,
					#[codec(index = 1)]
					FeePaid(_0),
					#[codec(index = 2)]
					Reasonable,
					#[codec(index = 3)]
					KnownGood,
					#[codec(index = 4)]
					OutOfDate,
					#[codec(index = 5)]
					LowQuality,
					#[codec(index = 6)]
					Erroneous,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct RegistrarInfo<_0, _1> {
					pub account: _1,
					pub fee: _0,
					pub fields: runtime_types::pallet_identity::types::BitFlags<
						runtime_types::pallet_identity::types::IdentityField,
					>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Registration<_0> {
					pub judgements: runtime_types::bounded_collections::bounded_vec::BoundedVec<(
						::core::primitive::u32,
						runtime_types::pallet_identity::types::Judgement<_0>,
					)>,
					pub deposit: _0,
					pub info: runtime_types::pallet_identity::types::IdentityInfo,
				}
			}
		}
		pub mod pallet_multisig {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					as_multi_threshold_1 {
						other_signatories: ::std::vec::Vec<::sp_core::crypto::AccountId32>,
						call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall>,
					},
					#[codec(index = 1)]
					as_multi {
						threshold: ::core::primitive::u16,
						other_signatories: ::std::vec::Vec<::sp_core::crypto::AccountId32>,
						maybe_timepoint: ::core::option::Option<
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						>,
						call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall>,
						max_weight: ::sp_weights::Weight,
					},
					#[codec(index = 2)]
					approve_as_multi {
						threshold: ::core::primitive::u16,
						other_signatories: ::std::vec::Vec<::sp_core::crypto::AccountId32>,
						maybe_timepoint: ::core::option::Option<
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						>,
						call_hash: [::core::primitive::u8; 32usize],
						max_weight: ::sp_weights::Weight,
					},
					#[codec(index = 3)]
					cancel_as_multi {
						threshold: ::core::primitive::u16,
						other_signatories: ::std::vec::Vec<::sp_core::crypto::AccountId32>,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						call_hash: [::core::primitive::u8; 32usize],
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					MinimumThreshold,
					#[codec(index = 1)]
					AlreadyApproved,
					#[codec(index = 2)]
					NoApprovalsNeeded,
					#[codec(index = 3)]
					TooFewSignatories,
					#[codec(index = 4)]
					TooManySignatories,
					#[codec(index = 5)]
					SignatoriesOutOfOrder,
					#[codec(index = 6)]
					SenderInSignatories,
					#[codec(index = 7)]
					NotFound,
					#[codec(index = 8)]
					NotOwner,
					#[codec(index = 9)]
					NoTimepoint,
					#[codec(index = 10)]
					WrongTimepoint,
					#[codec(index = 11)]
					UnexpectedTimepoint,
					#[codec(index = 12)]
					MaxWeightTooLow,
					#[codec(index = 13)]
					AlreadyStored,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					NewMultisig {
						approving: ::sp_core::crypto::AccountId32,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 1)]
					MultisigApproval {
						approving: ::sp_core::crypto::AccountId32,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
					},
					#[codec(index = 2)]
					MultisigExecuted {
						approving: ::sp_core::crypto::AccountId32,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
						result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
					#[codec(index = 3)]
					MultisigCancelled {
						cancelling: ::sp_core::crypto::AccountId32,
						timepoint:
							runtime_types::pallet_multisig::Timepoint<::core::primitive::u32>,
						multisig: ::sp_core::crypto::AccountId32,
						call_hash: [::core::primitive::u8; 32usize],
					},
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Multisig<_0, _1, _2> {
				pub when: runtime_types::pallet_multisig::Timepoint<_0>,
				pub deposit: _1,
				pub depositor: _2,
				pub approvals: runtime_types::bounded_collections::bounded_vec::BoundedVec<_2>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Timepoint<_0> {
				pub height: _0,
				pub index: _0,
			}
		}
		pub mod pallet_nomination_pools {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					join {
						#[codec(compact)]
						amount: ::core::primitive::u128,
						pool_id: ::core::primitive::u32,
					},
					#[codec(index = 1)]
					bond_extra {
						extra: runtime_types::pallet_nomination_pools::BondExtra<
							::core::primitive::u128,
						>,
					},
					#[codec(index = 2)]
					claim_payout,
					#[codec(index = 3)]
					unbond {
						member_account:
							::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						#[codec(compact)]
						unbonding_points: ::core::primitive::u128,
					},
					#[codec(index = 4)]
					pool_withdraw_unbonded {
						pool_id: ::core::primitive::u32,
						num_slashing_spans: ::core::primitive::u32,
					},
					#[codec(index = 5)]
					withdraw_unbonded {
						member_account:
							::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						num_slashing_spans: ::core::primitive::u32,
					},
					#[codec(index = 6)]
					create {
						#[codec(compact)]
						amount: ::core::primitive::u128,
						root: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						nominator: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						bouncer: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
					},
					#[codec(index = 7)]
					create_with_pool_id {
						#[codec(compact)]
						amount: ::core::primitive::u128,
						root: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						nominator: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						bouncer: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						pool_id: ::core::primitive::u32,
					},
					#[codec(index = 8)]
					nominate {
						pool_id: ::core::primitive::u32,
						validators: ::std::vec::Vec<::sp_core::crypto::AccountId32>,
					},
					#[codec(index = 9)]
					set_state {
						pool_id: ::core::primitive::u32,
						state: runtime_types::pallet_nomination_pools::PoolState,
					},
					#[codec(index = 10)]
					set_metadata {
						pool_id: ::core::primitive::u32,
						metadata: ::std::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 11)]
					set_configs {
						min_join_bond: runtime_types::pallet_nomination_pools::ConfigOp<
							::core::primitive::u128,
						>,
						min_create_bond: runtime_types::pallet_nomination_pools::ConfigOp<
							::core::primitive::u128,
						>,
						max_pools: runtime_types::pallet_nomination_pools::ConfigOp<
							::core::primitive::u32,
						>,
						max_members: runtime_types::pallet_nomination_pools::ConfigOp<
							::core::primitive::u32,
						>,
						max_members_per_pool: runtime_types::pallet_nomination_pools::ConfigOp<
							::core::primitive::u32,
						>,
						global_max_commission: runtime_types::pallet_nomination_pools::ConfigOp<
							runtime_types::sp_arithmetic::per_things::Perbill,
						>,
					},
					#[codec(index = 12)]
					update_roles {
						pool_id: ::core::primitive::u32,
						new_root: runtime_types::pallet_nomination_pools::ConfigOp<
							::sp_core::crypto::AccountId32,
						>,
						new_nominator: runtime_types::pallet_nomination_pools::ConfigOp<
							::sp_core::crypto::AccountId32,
						>,
						new_bouncer: runtime_types::pallet_nomination_pools::ConfigOp<
							::sp_core::crypto::AccountId32,
						>,
					},
					#[codec(index = 13)]
					chill { pool_id: ::core::primitive::u32 },
					#[codec(index = 14)]
					bond_extra_other {
						member: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						extra: runtime_types::pallet_nomination_pools::BondExtra<
							::core::primitive::u128,
						>,
					},
					#[codec(index = 15)]
					set_claim_permission {
						permission: runtime_types::pallet_nomination_pools::ClaimPermission,
					},
					#[codec(index = 16)]
					claim_payout_other { other: ::sp_core::crypto::AccountId32 },
					#[codec(index = 17)]
					set_commission {
						pool_id: ::core::primitive::u32,
						new_commission: ::core::option::Option<(
							runtime_types::sp_arithmetic::per_things::Perbill,
							::sp_core::crypto::AccountId32,
						)>,
					},
					#[codec(index = 18)]
					set_commission_max {
						pool_id: ::core::primitive::u32,
						max_commission: runtime_types::sp_arithmetic::per_things::Perbill,
					},
					#[codec(index = 19)]
					set_commission_change_rate {
						pool_id: ::core::primitive::u32,
						change_rate: runtime_types::pallet_nomination_pools::CommissionChangeRate<
							::core::primitive::u32,
						>,
					},
					#[codec(index = 20)]
					claim_commission { pool_id: ::core::primitive::u32 },
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum DefensiveError {
					#[codec(index = 0)]
					NotEnoughSpaceInUnbondPool,
					#[codec(index = 1)]
					PoolNotFound,
					#[codec(index = 2)]
					RewardPoolNotFound,
					#[codec(index = 3)]
					SubPoolsNotFound,
					#[codec(index = 4)]
					BondedStashKilledPrematurely,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					PoolNotFound,
					#[codec(index = 1)]
					PoolMemberNotFound,
					#[codec(index = 2)]
					RewardPoolNotFound,
					#[codec(index = 3)]
					SubPoolsNotFound,
					#[codec(index = 4)]
					AccountBelongsToOtherPool,
					#[codec(index = 5)]
					FullyUnbonding,
					#[codec(index = 6)]
					MaxUnbondingLimit,
					#[codec(index = 7)]
					CannotWithdrawAny,
					#[codec(index = 8)]
					MinimumBondNotMet,
					#[codec(index = 9)]
					OverflowRisk,
					#[codec(index = 10)]
					NotDestroying,
					#[codec(index = 11)]
					NotNominator,
					#[codec(index = 12)]
					NotKickerOrDestroying,
					#[codec(index = 13)]
					NotOpen,
					#[codec(index = 14)]
					MaxPools,
					#[codec(index = 15)]
					MaxPoolMembers,
					#[codec(index = 16)]
					CanNotChangeState,
					#[codec(index = 17)]
					DoesNotHavePermission,
					#[codec(index = 18)]
					MetadataExceedsMaxLen,
					#[codec(index = 19)]
					Defensive(runtime_types::pallet_nomination_pools::pallet::DefensiveError),
					#[codec(index = 20)]
					PartialUnbondNotAllowedPermissionlessly,
					#[codec(index = 21)]
					MaxCommissionRestricted,
					#[codec(index = 22)]
					CommissionExceedsMaximum,
					#[codec(index = 23)]
					CommissionChangeThrottled,
					#[codec(index = 24)]
					CommissionChangeRateNotAllowed,
					#[codec(index = 25)]
					NoPendingCommission,
					#[codec(index = 26)]
					NoCommissionCurrentSet,
					#[codec(index = 27)]
					PoolIdInUse,
					#[codec(index = 28)]
					InvalidPoolId,
					#[codec(index = 29)]
					BondExtraRestricted,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Created {
						depositor: ::sp_core::crypto::AccountId32,
						pool_id: ::core::primitive::u32,
					},
					#[codec(index = 1)]
					Bonded {
						member: ::sp_core::crypto::AccountId32,
						pool_id: ::core::primitive::u32,
						bonded: ::core::primitive::u128,
						joined: ::core::primitive::bool,
					},
					#[codec(index = 2)]
					PaidOut {
						member: ::sp_core::crypto::AccountId32,
						pool_id: ::core::primitive::u32,
						payout: ::core::primitive::u128,
					},
					#[codec(index = 3)]
					Unbonded {
						member: ::sp_core::crypto::AccountId32,
						pool_id: ::core::primitive::u32,
						balance: ::core::primitive::u128,
						points: ::core::primitive::u128,
						era: ::core::primitive::u32,
					},
					#[codec(index = 4)]
					Withdrawn {
						member: ::sp_core::crypto::AccountId32,
						pool_id: ::core::primitive::u32,
						balance: ::core::primitive::u128,
						points: ::core::primitive::u128,
					},
					#[codec(index = 5)]
					Destroyed { pool_id: ::core::primitive::u32 },
					#[codec(index = 6)]
					StateChanged {
						pool_id: ::core::primitive::u32,
						new_state: runtime_types::pallet_nomination_pools::PoolState,
					},
					#[codec(index = 7)]
					MemberRemoved {
						pool_id: ::core::primitive::u32,
						member: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 8)]
					RolesUpdated {
						root: ::core::option::Option<::sp_core::crypto::AccountId32>,
						bouncer: ::core::option::Option<::sp_core::crypto::AccountId32>,
						nominator: ::core::option::Option<::sp_core::crypto::AccountId32>,
					},
					#[codec(index = 9)]
					PoolSlashed {
						pool_id: ::core::primitive::u32,
						balance: ::core::primitive::u128,
					},
					#[codec(index = 10)]
					UnbondingPoolSlashed {
						pool_id: ::core::primitive::u32,
						era: ::core::primitive::u32,
						balance: ::core::primitive::u128,
					},
					#[codec(index = 11)]
					PoolCommissionUpdated {
						pool_id: ::core::primitive::u32,
						current: ::core::option::Option<(
							runtime_types::sp_arithmetic::per_things::Perbill,
							::sp_core::crypto::AccountId32,
						)>,
					},
					#[codec(index = 12)]
					PoolMaxCommissionUpdated {
						pool_id: ::core::primitive::u32,
						max_commission: runtime_types::sp_arithmetic::per_things::Perbill,
					},
					#[codec(index = 13)]
					PoolCommissionChangeRateUpdated {
						pool_id: ::core::primitive::u32,
						change_rate: runtime_types::pallet_nomination_pools::CommissionChangeRate<
							::core::primitive::u32,
						>,
					},
					#[codec(index = 14)]
					PoolCommissionClaimed {
						pool_id: ::core::primitive::u32,
						commission: ::core::primitive::u128,
					},
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum BondExtra<_0> {
				#[codec(index = 0)]
				FreeBalance(_0),
				#[codec(index = 1)]
				Rewards,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct BondedPoolInner {
				pub commission: runtime_types::pallet_nomination_pools::Commission,
				pub member_counter: ::core::primitive::u32,
				pub points: ::core::primitive::u128,
				pub roles: runtime_types::pallet_nomination_pools::PoolRoles<
					::sp_core::crypto::AccountId32,
				>,
				pub state: runtime_types::pallet_nomination_pools::PoolState,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum ClaimPermission {
				#[codec(index = 0)]
				Permissioned,
				#[codec(index = 1)]
				PermissionlessCompound,
				#[codec(index = 2)]
				PermissionlessWithdraw,
				#[codec(index = 3)]
				PermissionlessAll,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Commission {
				pub current: ::core::option::Option<(
					runtime_types::sp_arithmetic::per_things::Perbill,
					::sp_core::crypto::AccountId32,
				)>,
				pub max: ::core::option::Option<runtime_types::sp_arithmetic::per_things::Perbill>,
				pub change_rate: ::core::option::Option<
					runtime_types::pallet_nomination_pools::CommissionChangeRate<
						::core::primitive::u32,
					>,
				>,
				pub throttle_from: ::core::option::Option<::core::primitive::u32>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct CommissionChangeRate<_0> {
				pub max_increase: runtime_types::sp_arithmetic::per_things::Perbill,
				pub min_delay: _0,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum ConfigOp<_0> {
				#[codec(index = 0)]
				Noop,
				#[codec(index = 1)]
				Set(_0),
				#[codec(index = 2)]
				Remove,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct PoolMember {
				pub pool_id: ::core::primitive::u32,
				pub points: ::core::primitive::u128,
				pub last_recorded_reward_counter:
					runtime_types::sp_arithmetic::fixed_point::FixedU128,
				pub unbonding_eras:
					runtime_types::bounded_collections::bounded_btree_map::BoundedBTreeMap<
						::core::primitive::u32,
						::core::primitive::u128,
					>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct PoolRoles<_0> {
				pub depositor: _0,
				pub root: ::core::option::Option<_0>,
				pub nominator: ::core::option::Option<_0>,
				pub bouncer: ::core::option::Option<_0>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum PoolState {
				#[codec(index = 0)]
				Open,
				#[codec(index = 1)]
				Blocked,
				#[codec(index = 2)]
				Destroying,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct RewardPool {
				pub last_recorded_reward_counter:
					runtime_types::sp_arithmetic::fixed_point::FixedU128,
				pub last_recorded_total_payouts: ::core::primitive::u128,
				pub total_rewards_claimed: ::core::primitive::u128,
				pub total_commission_pending: ::core::primitive::u128,
				pub total_commission_claimed: ::core::primitive::u128,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct SubPools {
				pub no_era: runtime_types::pallet_nomination_pools::UnbondPool,
				pub with_era:
					runtime_types::bounded_collections::bounded_btree_map::BoundedBTreeMap<
						::core::primitive::u32,
						runtime_types::pallet_nomination_pools::UnbondPool,
					>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct UnbondPool {
				pub points: ::core::primitive::u128,
				pub balance: ::core::primitive::u128,
			}
		}
		pub mod pallet_scheduler {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					schedule {
						when: ::core::primitive::u32,
						maybe_periodic: ::core::option::Option<(
							::core::primitive::u32,
							::core::primitive::u32,
						)>,
						priority: ::core::primitive::u8,
						call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall>,
					},
					#[codec(index = 1)]
					cancel { when: ::core::primitive::u32, index: ::core::primitive::u32 },
					#[codec(index = 2)]
					schedule_named {
						id: [::core::primitive::u8; 32usize],
						when: ::core::primitive::u32,
						maybe_periodic: ::core::option::Option<(
							::core::primitive::u32,
							::core::primitive::u32,
						)>,
						priority: ::core::primitive::u8,
						call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall>,
					},
					#[codec(index = 3)]
					cancel_named { id: [::core::primitive::u8; 32usize] },
					#[codec(index = 4)]
					schedule_after {
						after: ::core::primitive::u32,
						maybe_periodic: ::core::option::Option<(
							::core::primitive::u32,
							::core::primitive::u32,
						)>,
						priority: ::core::primitive::u8,
						call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall>,
					},
					#[codec(index = 5)]
					schedule_named_after {
						id: [::core::primitive::u8; 32usize],
						after: ::core::primitive::u32,
						maybe_periodic: ::core::option::Option<(
							::core::primitive::u32,
							::core::primitive::u32,
						)>,
						priority: ::core::primitive::u8,
						call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall>,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					FailedToSchedule,
					#[codec(index = 1)]
					NotFound,
					#[codec(index = 2)]
					TargetBlockNumberInPast,
					#[codec(index = 3)]
					RescheduleNoChange,
					#[codec(index = 4)]
					Named,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Scheduled { when: ::core::primitive::u32, index: ::core::primitive::u32 },
					#[codec(index = 1)]
					Canceled { when: ::core::primitive::u32, index: ::core::primitive::u32 },
					#[codec(index = 2)]
					Dispatched {
						task: (::core::primitive::u32, ::core::primitive::u32),
						id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
						result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
					#[codec(index = 3)]
					CallUnavailable {
						task: (::core::primitive::u32, ::core::primitive::u32),
						id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
					},
					#[codec(index = 4)]
					PeriodicFailed {
						task: (::core::primitive::u32, ::core::primitive::u32),
						id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
					},
					#[codec(index = 5)]
					PermanentlyOverweight {
						task: (::core::primitive::u32, ::core::primitive::u32),
						id: ::core::option::Option<[::core::primitive::u8; 32usize]>,
					},
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Scheduled<_0, _1, _2, _3, _4> {
				pub maybe_id: ::core::option::Option<_0>,
				pub priority: ::core::primitive::u8,
				pub call: _1,
				pub maybe_periodic: ::core::option::Option<(_2, _2)>,
				pub origin: _3,
				#[codec(skip)]
				pub __subxt_unused_type_params: ::core::marker::PhantomData<_4>,
			}
		}
		pub mod pallet_session {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set_keys {
						keys: runtime_types::aleph_runtime::SessionKeys,
						proof: ::std::vec::Vec<::core::primitive::u8>,
					},
					#[codec(index = 1)]
					purge_keys,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InvalidProof,
					#[codec(index = 1)]
					NoAssociatedValidatorId,
					#[codec(index = 2)]
					DuplicatedKey,
					#[codec(index = 3)]
					NoKeys,
					#[codec(index = 4)]
					NoAccount,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					NewSession { session_index: ::core::primitive::u32 },
				}
			}
		}
		pub mod pallet_staking {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				pub mod pallet {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Call {
						#[codec(index = 0)]
						bond {
							controller:
								::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
							#[codec(compact)]
							value: ::core::primitive::u128,
							payee: runtime_types::pallet_staking::RewardDestination<
								::sp_core::crypto::AccountId32,
							>,
						},
						#[codec(index = 1)]
						bond_extra {
							#[codec(compact)]
							max_additional: ::core::primitive::u128,
						},
						#[codec(index = 2)]
						unbond {
							#[codec(compact)]
							value: ::core::primitive::u128,
						},
						#[codec(index = 3)]
						withdraw_unbonded { num_slashing_spans: ::core::primitive::u32 },
						#[codec(index = 4)]
						validate { prefs: runtime_types::pallet_staking::ValidatorPrefs },
						#[codec(index = 5)]
						nominate {
							targets: ::std::vec::Vec<
								::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
							>,
						},
						#[codec(index = 6)]
						chill,
						#[codec(index = 7)]
						set_payee {
							payee: runtime_types::pallet_staking::RewardDestination<
								::sp_core::crypto::AccountId32,
							>,
						},
						#[codec(index = 8)]
						set_controller {
							controller:
								::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						},
						#[codec(index = 9)]
						set_validator_count {
							#[codec(compact)]
							new: ::core::primitive::u32,
						},
						#[codec(index = 10)]
						increase_validator_count {
							#[codec(compact)]
							additional: ::core::primitive::u32,
						},
						#[codec(index = 11)]
						scale_validator_count {
							factor: runtime_types::sp_arithmetic::per_things::Percent,
						},
						#[codec(index = 12)]
						force_no_eras,
						#[codec(index = 13)]
						force_new_era,
						#[codec(index = 14)]
						set_invulnerables {
							invulnerables: ::std::vec::Vec<::sp_core::crypto::AccountId32>,
						},
						#[codec(index = 15)]
						force_unstake {
							stash: ::sp_core::crypto::AccountId32,
							num_slashing_spans: ::core::primitive::u32,
						},
						#[codec(index = 16)]
						force_new_era_always,
						#[codec(index = 17)]
						cancel_deferred_slash {
							era: ::core::primitive::u32,
							slash_indices: ::std::vec::Vec<::core::primitive::u32>,
						},
						#[codec(index = 18)]
						payout_stakers {
							validator_stash: ::sp_core::crypto::AccountId32,
							era: ::core::primitive::u32,
						},
						#[codec(index = 19)]
						rebond {
							#[codec(compact)]
							value: ::core::primitive::u128,
						},
						#[codec(index = 20)]
						reap_stash {
							stash: ::sp_core::crypto::AccountId32,
							num_slashing_spans: ::core::primitive::u32,
						},
						#[codec(index = 21)]
						kick {
							who: ::std::vec::Vec<
								::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
							>,
						},
						#[codec(index = 22)]
						set_staking_configs {
							min_nominator_bond:
								runtime_types::pallet_staking::pallet::pallet::ConfigOp<
									::core::primitive::u128,
								>,
							min_validator_bond:
								runtime_types::pallet_staking::pallet::pallet::ConfigOp<
									::core::primitive::u128,
								>,
							max_nominator_count:
								runtime_types::pallet_staking::pallet::pallet::ConfigOp<
									::core::primitive::u32,
								>,
							max_validator_count:
								runtime_types::pallet_staking::pallet::pallet::ConfigOp<
									::core::primitive::u32,
								>,
							chill_threshold:
								runtime_types::pallet_staking::pallet::pallet::ConfigOp<
									runtime_types::sp_arithmetic::per_things::Percent,
								>,
							min_commission: runtime_types::pallet_staking::pallet::pallet::ConfigOp<
								runtime_types::sp_arithmetic::per_things::Perbill,
							>,
						},
						#[codec(index = 23)]
						chill_other { controller: ::sp_core::crypto::AccountId32 },
						#[codec(index = 24)]
						force_apply_min_commission {
							validator_stash: ::sp_core::crypto::AccountId32,
						},
						#[codec(index = 25)]
						set_min_commission {
							new: runtime_types::sp_arithmetic::per_things::Perbill,
						},
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum ConfigOp<_0> {
						#[codec(index = 0)]
						Noop,
						#[codec(index = 1)]
						Set(_0),
						#[codec(index = 2)]
						Remove,
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Error {
						#[codec(index = 0)]
						NotController,
						#[codec(index = 1)]
						NotStash,
						#[codec(index = 2)]
						AlreadyBonded,
						#[codec(index = 3)]
						AlreadyPaired,
						#[codec(index = 4)]
						EmptyTargets,
						#[codec(index = 5)]
						DuplicateIndex,
						#[codec(index = 6)]
						InvalidSlashIndex,
						#[codec(index = 7)]
						InsufficientBond,
						#[codec(index = 8)]
						NoMoreChunks,
						#[codec(index = 9)]
						NoUnlockChunk,
						#[codec(index = 10)]
						FundedTarget,
						#[codec(index = 11)]
						InvalidEraToReward,
						#[codec(index = 12)]
						InvalidNumberOfNominations,
						#[codec(index = 13)]
						NotSortedAndUnique,
						#[codec(index = 14)]
						AlreadyClaimed,
						#[codec(index = 15)]
						IncorrectHistoryDepth,
						#[codec(index = 16)]
						IncorrectSlashingSpans,
						#[codec(index = 17)]
						BadState,
						#[codec(index = 18)]
						TooManyTargets,
						#[codec(index = 19)]
						BadTarget,
						#[codec(index = 20)]
						CannotChillOther,
						#[codec(index = 21)]
						TooManyNominators,
						#[codec(index = 22)]
						TooManyValidators,
						#[codec(index = 23)]
						CommissionTooLow,
						#[codec(index = 24)]
						BoundNotMet,
					}
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum Event {
						#[codec(index = 0)]
						EraPaid {
							era_index: ::core::primitive::u32,
							validator_payout: ::core::primitive::u128,
							remainder: ::core::primitive::u128,
						},
						#[codec(index = 1)]
						Rewarded {
							stash: ::sp_core::crypto::AccountId32,
							amount: ::core::primitive::u128,
						},
						#[codec(index = 2)]
						Slashed {
							staker: ::sp_core::crypto::AccountId32,
							amount: ::core::primitive::u128,
						},
						#[codec(index = 3)]
						SlashReported {
							validator: ::sp_core::crypto::AccountId32,
							fraction: runtime_types::sp_arithmetic::per_things::Perbill,
							slash_era: ::core::primitive::u32,
						},
						#[codec(index = 4)]
						OldSlashingReportDiscarded { session_index: ::core::primitive::u32 },
						#[codec(index = 5)]
						StakersElected,
						#[codec(index = 6)]
						Bonded {
							stash: ::sp_core::crypto::AccountId32,
							amount: ::core::primitive::u128,
						},
						#[codec(index = 7)]
						Unbonded {
							stash: ::sp_core::crypto::AccountId32,
							amount: ::core::primitive::u128,
						},
						#[codec(index = 8)]
						Withdrawn {
							stash: ::sp_core::crypto::AccountId32,
							amount: ::core::primitive::u128,
						},
						#[codec(index = 9)]
						Kicked {
							nominator: ::sp_core::crypto::AccountId32,
							stash: ::sp_core::crypto::AccountId32,
						},
						#[codec(index = 10)]
						StakingElectionFailed,
						#[codec(index = 11)]
						Chilled { stash: ::sp_core::crypto::AccountId32 },
						#[codec(index = 12)]
						PayoutStarted {
							era_index: ::core::primitive::u32,
							validator_stash: ::sp_core::crypto::AccountId32,
						},
						#[codec(index = 13)]
						ValidatorPrefsSet {
							stash: ::sp_core::crypto::AccountId32,
							prefs: runtime_types::pallet_staking::ValidatorPrefs,
						},
						#[codec(index = 14)]
						ForceEra { mode: runtime_types::pallet_staking::Forcing },
					}
				}
			}
			pub mod slashing {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct SlashingSpans {
					pub span_index: ::core::primitive::u32,
					pub last_start: ::core::primitive::u32,
					pub last_nonzero_slash: ::core::primitive::u32,
					pub prior: ::std::vec::Vec<::core::primitive::u32>,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct SpanRecord<_0> {
					pub slashed: _0,
					pub paid_out: _0,
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ActiveEraInfo {
				pub index: ::core::primitive::u32,
				pub start: ::core::option::Option<::core::primitive::u64>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct EraRewardPoints<_0> {
				pub total: ::core::primitive::u32,
				pub individual: ::subxt::utils::KeyedVec<_0, ::core::primitive::u32>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Exposure<_0, _1> {
				#[codec(compact)]
				pub total: _1,
				#[codec(compact)]
				pub own: _1,
				pub others:
					::std::vec::Vec<runtime_types::pallet_staking::IndividualExposure<_0, _1>>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum Forcing {
				#[codec(index = 0)]
				NotForcing,
				#[codec(index = 1)]
				ForceNew,
				#[codec(index = 2)]
				ForceNone,
				#[codec(index = 3)]
				ForceAlways,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct IndividualExposure<_0, _1> {
				pub who: _0,
				#[codec(compact)]
				pub value: _1,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Nominations {
				pub targets: runtime_types::bounded_collections::bounded_vec::BoundedVec<
					::sp_core::crypto::AccountId32,
				>,
				pub submitted_in: ::core::primitive::u32,
				pub suppressed: ::core::primitive::bool,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum RewardDestination<_0> {
				#[codec(index = 0)]
				Staked,
				#[codec(index = 1)]
				Stash,
				#[codec(index = 2)]
				Controller,
				#[codec(index = 3)]
				Account(_0),
				#[codec(index = 4)]
				None,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct StakingLedger {
				pub stash: ::sp_core::crypto::AccountId32,
				#[codec(compact)]
				pub total: ::core::primitive::u128,
				#[codec(compact)]
				pub active: ::core::primitive::u128,
				pub unlocking: runtime_types::bounded_collections::bounded_vec::BoundedVec<
					runtime_types::pallet_staking::UnlockChunk<::core::primitive::u128>,
				>,
				pub claimed_rewards: runtime_types::bounded_collections::bounded_vec::BoundedVec<
					::core::primitive::u32,
				>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct UnappliedSlash<_0, _1> {
				pub validator: _0,
				pub own: _1,
				pub others: ::std::vec::Vec<(_0, _1)>,
				pub reporters: ::std::vec::Vec<_0>,
				pub payout: _1,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct UnlockChunk<_0> {
				#[codec(compact)]
				pub value: _0,
				#[codec(compact)]
				pub era: ::core::primitive::u32,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ValidatorPrefs {
				#[codec(compact)]
				pub commission: runtime_types::sp_arithmetic::per_things::Perbill,
				pub blocked: ::core::primitive::bool,
			}
		}
		pub mod pallet_sudo {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					sudo { call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall> },
					#[codec(index = 1)]
					sudo_unchecked_weight {
						call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall>,
						weight: ::sp_weights::Weight,
					},
					#[codec(index = 2)]
					set_key {
						new: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
					},
					#[codec(index = 3)]
					sudo_as {
						who: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall>,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					RequireSudo,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Sudid {
						sudo_result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
					#[codec(index = 1)]
					KeyChanged {
						old_sudoer: ::core::option::Option<::sp_core::crypto::AccountId32>,
					},
					#[codec(index = 2)]
					SudoAsDone {
						sudo_result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
				}
			}
		}
		pub mod pallet_timestamp {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					set {
						#[codec(compact)]
						now: ::core::primitive::u64,
					},
				}
			}
		}
		pub mod pallet_transaction_payment {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					TransactionFeePaid {
						who: ::sp_core::crypto::AccountId32,
						actual_fee: ::core::primitive::u128,
						tip: ::core::primitive::u128,
					},
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ChargeTransactionPayment(#[codec(compact)] pub ::core::primitive::u128);
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum Releases {
				#[codec(index = 0)]
				V1Ancient,
				#[codec(index = 1)]
				V2,
			}
		}
		pub mod pallet_treasury {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					propose_spend {
						#[codec(compact)]
						value: ::core::primitive::u128,
						beneficiary:
							::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
					},
					#[codec(index = 1)]
					reject_proposal {
						#[codec(compact)]
						proposal_id: ::core::primitive::u32,
					},
					#[codec(index = 2)]
					approve_proposal {
						#[codec(compact)]
						proposal_id: ::core::primitive::u32,
					},
					#[codec(index = 3)]
					spend {
						#[codec(compact)]
						amount: ::core::primitive::u128,
						beneficiary:
							::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
					},
					#[codec(index = 4)]
					remove_approval {
						#[codec(compact)]
						proposal_id: ::core::primitive::u32,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					InsufficientProposersBalance,
					#[codec(index = 1)]
					InvalidIndex,
					#[codec(index = 2)]
					TooManyApprovals,
					#[codec(index = 3)]
					InsufficientPermission,
					#[codec(index = 4)]
					ProposalNotApproved,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					Proposed { proposal_index: ::core::primitive::u32 },
					#[codec(index = 1)]
					Spending { budget_remaining: ::core::primitive::u128 },
					#[codec(index = 2)]
					Awarded {
						proposal_index: ::core::primitive::u32,
						award: ::core::primitive::u128,
						account: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 3)]
					Rejected {
						proposal_index: ::core::primitive::u32,
						slashed: ::core::primitive::u128,
					},
					#[codec(index = 4)]
					Burnt { burnt_funds: ::core::primitive::u128 },
					#[codec(index = 5)]
					Rollover { rollover_balance: ::core::primitive::u128 },
					#[codec(index = 6)]
					Deposit { value: ::core::primitive::u128 },
					#[codec(index = 7)]
					SpendApproved {
						proposal_index: ::core::primitive::u32,
						amount: ::core::primitive::u128,
						beneficiary: ::sp_core::crypto::AccountId32,
					},
					#[codec(index = 8)]
					UpdatedInactive {
						reactivated: ::core::primitive::u128,
						deactivated: ::core::primitive::u128,
					},
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct Proposal<_0, _1> {
				pub proposer: _0,
				pub value: _1,
				pub beneficiary: _0,
				pub bond: _1,
			}
		}
		pub mod pallet_utility {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					batch { calls: ::std::vec::Vec<runtime_types::aleph_runtime::RuntimeCall> },
					#[codec(index = 1)]
					as_derivative {
						index: ::core::primitive::u16,
						call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall>,
					},
					#[codec(index = 2)]
					batch_all { calls: ::std::vec::Vec<runtime_types::aleph_runtime::RuntimeCall> },
					#[codec(index = 3)]
					dispatch_as {
						as_origin: ::std::boxed::Box<runtime_types::aleph_runtime::OriginCaller>,
						call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall>,
					},
					#[codec(index = 4)]
					force_batch {
						calls: ::std::vec::Vec<runtime_types::aleph_runtime::RuntimeCall>,
					},
					#[codec(index = 5)]
					with_weight {
						call: ::std::boxed::Box<runtime_types::aleph_runtime::RuntimeCall>,
						weight: ::sp_weights::Weight,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					TooManyCalls,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					BatchInterrupted {
						index: ::core::primitive::u32,
						error: runtime_types::sp_runtime::DispatchError,
					},
					#[codec(index = 1)]
					BatchCompleted,
					#[codec(index = 2)]
					BatchCompletedWithErrors,
					#[codec(index = 3)]
					ItemCompleted,
					#[codec(index = 4)]
					ItemFailed { error: runtime_types::sp_runtime::DispatchError },
					#[codec(index = 5)]
					DispatchedAs {
						result:
							::core::result::Result<(), runtime_types::sp_runtime::DispatchError>,
					},
				}
			}
		}
		pub mod pallet_vesting {
			use super::runtime_types;
			pub mod pallet {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Call {
					#[codec(index = 0)]
					vest,
					#[codec(index = 1)]
					vest_other {
						target: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
					},
					#[codec(index = 2)]
					vested_transfer {
						target: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						schedule: runtime_types::pallet_vesting::vesting_info::VestingInfo<
							::core::primitive::u128,
							::core::primitive::u32,
						>,
					},
					#[codec(index = 3)]
					force_vested_transfer {
						source: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						target: ::subxt::utils::MultiAddress<::sp_core::crypto::AccountId32, ()>,
						schedule: runtime_types::pallet_vesting::vesting_info::VestingInfo<
							::core::primitive::u128,
							::core::primitive::u32,
						>,
					},
					#[codec(index = 4)]
					merge_schedules {
						schedule1_index: ::core::primitive::u32,
						schedule2_index: ::core::primitive::u32,
					},
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Error {
					#[codec(index = 0)]
					NotVesting,
					#[codec(index = 1)]
					AtMaxVestingSchedules,
					#[codec(index = 2)]
					AmountLow,
					#[codec(index = 3)]
					ScheduleIndexOutOfBounds,
					#[codec(index = 4)]
					InvalidScheduleParams,
				}
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub enum Event {
					#[codec(index = 0)]
					VestingUpdated {
						account: ::sp_core::crypto::AccountId32,
						unvested: ::core::primitive::u128,
					},
					#[codec(index = 1)]
					VestingCompleted { account: ::sp_core::crypto::AccountId32 },
				}
			}
			pub mod vesting_info {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct VestingInfo<_0, _1> {
					pub locked: _0,
					pub per_block: _0,
					pub starting_block: _1,
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum Releases {
				#[codec(index = 0)]
				V0,
				#[codec(index = 1)]
				V1,
			}
		}
		pub mod primitives {
			use super::runtime_types;
			pub mod app {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Public(pub runtime_types::sp_core::ed25519::Public);
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct BanConfig {
				pub minimal_expected_performance: runtime_types::sp_arithmetic::per_things::Perbill,
				pub underperformed_session_count_threshold: ::core::primitive::u32,
				pub clean_session_counter_delay: ::core::primitive::u32,
				pub ban_period: ::core::primitive::u32,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct BanInfo {
				pub reason: runtime_types::primitives::BanReason,
				pub start: ::core::primitive::u32,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum BanReason {
				#[codec(index = 0)]
				InsufficientUptime(::core::primitive::u32),
				#[codec(index = 1)]
				OtherReason(
					runtime_types::bounded_collections::bounded_vec::BoundedVec<
						::core::primitive::u8,
					>,
				),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct CommitteeSeats {
				pub reserved_seats: ::core::primitive::u32,
				pub non_reserved_seats: ::core::primitive::u32,
				pub non_reserved_finality_seats: ::core::primitive::u32,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum ElectionOpenness {
				#[codec(index = 0)]
				Permissioned,
				#[codec(index = 1)]
				Permissionless,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct EraValidators<_0> {
				pub reserved: ::std::vec::Vec<_0>,
				pub non_reserved: ::std::vec::Vec<_0>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct SessionValidators<_0> {
				pub committee: ::std::vec::Vec<_0>,
				pub non_committee: ::std::vec::Vec<_0>,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct VersionChange {
				pub version_incoming: ::core::primitive::u32,
				pub session: ::core::primitive::u32,
			}
		}
		pub mod sp_arithmetic {
			use super::runtime_types;
			pub mod fixed_point {
				use super::runtime_types;
				#[derive(
					:: codec :: Decode,
					:: codec :: Encode,
					:: subxt :: ext :: codec :: CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct FixedU128(pub ::core::primitive::u128);
			}
			pub mod per_things {
				use super::runtime_types;
				#[derive(
					:: codec :: Decode,
					:: codec :: Encode,
					:: subxt :: ext :: codec :: CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct Perbill(pub ::core::primitive::u32);
				#[derive(
					:: codec :: Decode,
					:: codec :: Encode,
					:: subxt :: ext :: codec :: CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct Percent(pub ::core::primitive::u8);
				#[derive(
					:: codec :: Decode,
					:: codec :: Encode,
					:: subxt :: ext :: codec :: CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct Permill(pub ::core::primitive::u32);
				#[derive(
					:: codec :: Decode,
					:: codec :: Encode,
					:: subxt :: ext :: codec :: CompactAs,
					Clone,
					Debug,
					PartialEq,
				)]
				pub struct Perquintill(pub ::core::primitive::u64);
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum ArithmeticError {
				#[codec(index = 0)]
				Underflow,
				#[codec(index = 1)]
				Overflow,
				#[codec(index = 2)]
				DivisionByZero,
			}
		}
		pub mod sp_consensus_aura {
			use super::runtime_types;
			pub mod sr25519 {
				use super::runtime_types;
				pub mod app_sr25519 {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct Public(pub runtime_types::sp_core::sr25519::Public);
				}
			}
		}
		pub mod sp_consensus_grandpa {
			use super::runtime_types;
			pub mod app {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Public(pub runtime_types::sp_core::ed25519::Public);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub runtime_types::sp_core::ed25519::Signature);
			}
		}
		pub mod sp_consensus_slots {
			use super::runtime_types;
			#[derive(
				:: codec :: Decode,
				:: codec :: Encode,
				:: subxt :: ext :: codec :: CompactAs,
				Clone,
				Debug,
				PartialEq,
			)]
			pub struct Slot(pub ::core::primitive::u64);
		}
		pub mod sp_core {
			use super::runtime_types;
			pub mod crypto {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct KeyTypeId(pub [::core::primitive::u8; 4usize]);
			}
			pub mod ecdsa {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub [::core::primitive::u8; 65usize]);
			}
			pub mod ed25519 {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Public(pub [::core::primitive::u8; 32usize]);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub [::core::primitive::u8; 64usize]);
			}
			pub mod sr25519 {
				use super::runtime_types;
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Public(pub [::core::primitive::u8; 32usize]);
				#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
				pub struct Signature(pub [::core::primitive::u8; 64usize]);
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum Void {}
		}
		pub mod sp_runtime {
			use super::runtime_types;
			pub mod generic {
				use super::runtime_types;
				pub mod digest {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub enum DigestItem {
						#[codec(index = 6)]
						PreRuntime(
							[::core::primitive::u8; 4usize],
							::std::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 4)]
						Consensus(
							[::core::primitive::u8; 4usize],
							::std::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 5)]
						Seal(
							[::core::primitive::u8; 4usize],
							::std::vec::Vec<::core::primitive::u8>,
						),
						#[codec(index = 0)]
						Other(::std::vec::Vec<::core::primitive::u8>),
						#[codec(index = 8)]
						RuntimeEnvironmentUpdated,
					}
				}
				pub mod unchecked_extrinsic {
					use super::runtime_types;
					#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
					pub struct UncheckedExtrinsic<_0, _1, _2, _3>(
						pub ::std::vec::Vec<::core::primitive::u8>,
						#[codec(skip)] pub ::core::marker::PhantomData<(_1, _0, _2, _3)>,
					);
				}
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum DispatchError {
				#[codec(index = 0)]
				Other,
				#[codec(index = 1)]
				CannotLookup,
				#[codec(index = 2)]
				BadOrigin,
				#[codec(index = 3)]
				Module(runtime_types::sp_runtime::ModuleError),
				#[codec(index = 4)]
				ConsumerRemaining,
				#[codec(index = 5)]
				NoProviders,
				#[codec(index = 6)]
				TooManyConsumers,
				#[codec(index = 7)]
				Token(runtime_types::sp_runtime::TokenError),
				#[codec(index = 8)]
				Arithmetic(runtime_types::sp_arithmetic::ArithmeticError),
				#[codec(index = 9)]
				Transactional(runtime_types::sp_runtime::TransactionalError),
				#[codec(index = 10)]
				Exhausted,
				#[codec(index = 11)]
				Corruption,
				#[codec(index = 12)]
				Unavailable,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct ModuleError {
				pub index: ::core::primitive::u8,
				pub error: [::core::primitive::u8; 4usize],
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum MultiSignature {
				#[codec(index = 0)]
				Ed25519(runtime_types::sp_core::ed25519::Signature),
				#[codec(index = 1)]
				Sr25519(runtime_types::sp_core::sr25519::Signature),
				#[codec(index = 2)]
				Ecdsa(runtime_types::sp_core::ecdsa::Signature),
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum TokenError {
				#[codec(index = 0)]
				NoFunds,
				#[codec(index = 1)]
				WouldDie,
				#[codec(index = 2)]
				BelowMinimum,
				#[codec(index = 3)]
				CannotCreate,
				#[codec(index = 4)]
				UnknownAsset,
				#[codec(index = 5)]
				Frozen,
				#[codec(index = 6)]
				Unsupported,
			}
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub enum TransactionalError {
				#[codec(index = 0)]
				LimitReached,
				#[codec(index = 1)]
				NoLayer,
			}
		}
		pub mod sp_version {
			use super::runtime_types;
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct RuntimeVersion {
				pub spec_name: ::std::string::String,
				pub impl_name: ::std::string::String,
				pub authoring_version: ::core::primitive::u32,
				pub spec_version: ::core::primitive::u32,
				pub impl_version: ::core::primitive::u32,
				pub apis:
					::std::vec::Vec<([::core::primitive::u8; 8usize], ::core::primitive::u32)>,
				pub transaction_version: ::core::primitive::u32,
				pub state_version: ::core::primitive::u8,
			}
		}
		pub mod sp_weights {
			use super::runtime_types;
			#[derive(
				:: codec :: Decode,
				:: codec :: Encode,
				:: subxt :: ext :: codec :: CompactAs,
				Clone,
				Debug,
				PartialEq,
			)]
			pub struct OldWeight(pub ::core::primitive::u64);
			#[derive(:: codec :: Decode, :: codec :: Encode, Clone, Debug, PartialEq)]
			pub struct RuntimeDbWeight {
				pub read: ::core::primitive::u64,
				pub write: ::core::primitive::u64,
			}
		}
	}
}
